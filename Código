<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css"> 
 <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"> 

 <title>Sudoku</title>
 <style>
   @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap");
/* Password: 24040540501 */
* {
    padding: 0;
    margin: 0;
    box-sizing: border-box;
    font-family: "Poppins";
}

body {
    min-height: 100vh;
    display: grid;
    place-items: center;
    font-family: "Poppins";
}

.sudoku {
    display: flex;
    flex-direction: column;
}
/* =============== Popup messages ========= */
.board-and-messages{
    position: relative;
    display: flex;
    flex-direction: column;
    align-self: center;
    align-items: center;
    justify-content: center;
}

.board-and-messages p{
    position: absolute;
    text-align: center;
    top: 0;
    z-index: -1;
    width: 100%;
    padding: 0.25rem 0;
    background-color: blanchedalmond;
    font-size: 0.8rem;
    transition: transform 0.2s ease-in-out;
}

.board-and-messages p{
    justify-content: center;
    align-items: center;
    display: flex;
    flex-direction: row;
    column-gap: 0.25rem;
}

.board-and-messages p span {
    display: flex;
    justify-content: center;
}


.board-and-messages #unsolvable, .board-and-messages #invalid-board {
    background-color: hsl(0, 100%, 90%);
    color: hsl(0, 100%, 30%);
}

/* Unsolvable Message */
.board-and-messages #unsolvable svg{
    width: 80%;
    fill: hsl(0, 100%, 30%);
}
/*  */

/* Invalid message */
.board-and-messages #invalid-board svg{
    width: 80%;
    fill: hsl(0, 100%, 30%);
}

.board-and-messages #invalid-board svg path{
    width: 80%;
    fill: hsl(0, 100%, 30%);
}
/*  */

/* Solved Message */
.board-and-messages #solved{
    background-color: hsl(120, 100%, 90%);
    color: hsl(120, 100%, 30%);
    column-gap: 0.25rem;
}

.board-and-messages #solved svg{
    width: 80%;
    fill: hsl(120, 100%, 30%);
}
/*  */

/* Solving Message */
.board-and-messages #solving{
    background-color: hsl(211, 100%, 95%);
    color: hsl(211, 100%, 40%);
    column-gap: 0.25rem;
}

.board-and-messages #solving svg{
    width: 80%;
    fill: hsl(211, 100%, 40%);
    animation: rotate 5s linear infinite;
}

@keyframes rotate{
    0% {
        transform: rotateZ(0deg);
    }

    100%{
        transform: rotateZ(360deg);
    }
}
/*  */

/* ================== PopUp Messages End ====================== */

/* =========== Canvas layout ====== */
#canvas-sudoku {
    width: 90vw;
    max-width: 600px;
    background-color: white;
    outline: 3px solid black;
    border-radius: 6px;
}
/* =========== Canvas layout Ends ====== */

.controls {
    margin-top: 1rem;
}

.tools {
    /* background-color: seagreen; */
    margin-top: 1rem;
    display: grid;
    width: 100%;
    grid-template-columns: repeat(5, 16%);
    justify-items: center;
    justify-content: space-between;
    column-gap: 0.1rem;
    row-gap: 0.5rem;
    padding: 0 1rem;
}

.tools button {
    position: relative;
    max-width: 4rem;
    width: 15vw;
    min-width: 3rem;
    max-height: 4rem;
    height: 15vw;
    min-height: 3rem;
    padding: 0.75rem;
    border-radius: 50%;
    grid-row: 1;
    outline: none;
    border: none;
    cursor: pointer;
}

.tools label {
    text-align: center;
    font-weight: 500;
    font-size: 0.75rem;
    align-self: unset;
}

.tools button img {
    width: 100%;
}

.tools button svg {
    width: 100%;
}

#notes-activity{
    position: absolute;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    background-color: rgb(240, 240, 240);
    font-size: 0.75rem;
    border: 2px solid white;
    font-weight: 500;
    right: 0;
    bottom: 0;
    transform: translate(40%,30%);
    transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

/* Num inputs */
.num-inputs{
    margin-top: 0.5rem;
    display: flex;
    justify-content: center;
    padding: 0 1rem;
    gap: 0.1rem;
}

.num-inputs button{
    width: 100%;
    padding: 1%;
    outline: none;
    border: none;
    cursor: pointer;
    font-size: 2rem;
    border-radius: 0.15rem;
    background-color: hsl(211, 100%, 95%);
    color: hsl(211, 100%, 40%);
}

.num-inputs button path{
    fill: hsl(211, 100%, 40%);
}

/* Buttons with slider controls */
.controls {
    display: flex;
    flex-direction: row;
    background-color: white;
    padding: 0 1rem;
    gap: 0.25rem;
    width: 100%;
    justify-content: space-between;
}

.controls .solving-controls,
.controls .generate-controls {
    display: grid;
    grid-template-columns: 1fr 3fr;
    gap: 0.5rem;
    /* background-color: yellow; */
}
.solving-controls,
.generate-controls {
    width: 100%;
}

.solving-controls > label,
.generate-controls > label {
    font-weight: 500;
    font-size: 0.8rem;
    grid-column: 2;
    align-self: center;
}

.solving-controls button,
.generate-controls button {
    max-width: 4rem;
    width: 15vw;
    min-width: 3rem;
    max-height: 4rem;
    height: 15vw;
    min-height: 3rem;
    border-radius: 50%;
    padding: 0.75rem;
    outline: none;
    border: none;
    cursor: pointer;
    align-self: center;
    justify-self: center;
    grid-row: 1;
    background-color: rgb(240, 240, 240);
}

.solving-controls button,
.generate-controls button {
    position: relative;
    max-width: 4rem;
    width: 15vw;
    min-width: 3rem;
    max-height: 4rem;
    height: 15vw;
    min-height: 3rem;
    border-radius: 50%;
    padding: 0.75rem;
    outline: none;
    border: none;
    cursor: pointer;
    align-self: center;
    justify-self: center;
}


.solving-controls .speed-control,
.generate-controls .empty-cell {
    width: 100%;
    grid-column: span 2;
}

.solving-controls button img,
.generate-controls button img {
    width: 100%;
}

.empty-cell p,
.speed-control p {
    display: grid;
    grid-template-columns: repeat(2, 50%);
    width: 90%;
}

.empty-cell > label,
.speed-control > label {
    font-weight: 400;
    font-size: 0.75rem;
    
}

.empty-cell p input,
.speed-control p input {
    grid-row: 1;
    grid-column: span 2;
    width: 100%;
}

.empty-cell p .min,
.speed-control p .min {
    font-weight: 400;
    font-size: 0.75rem;
    justify-self: start;
}

.empty-cell p .max,
.speed-control p .max {
    font-weight: 400;
    font-size: 0.75rem;
    justify-self: end;
}

#solve-state{
    position: absolute;
    padding: 0.20rem 0.35rem;
    border-radius: 1rem;
    background-color: hsl(211, 100%, 90%);
    color: hsl(211, 100%, 40%);
    font-size: 0.75rem;
    border: 2px solid white;
    font-weight: 500;
    right: 0;
    bottom: 0;
    transform: translate(40%,30%);
    transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}



@media screen and (max-width: 19rem) {
    /* .tools button {
        width:3rem;
        height: 3rem;
    } */

    .solving-controls button,
    .generate-controls button {
        width: 3rem;
        height: 3rem;
    }
}
  
 </style>
<body>
  <button onclick="mostrarAlertaCalificacionManual()" style="background-color: #FFFFFF; /* Blanco */
  border: 2px solid #000000; /* Negro */
  color: #000000; /* Negro */
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 8px;
  animation: cambioColor 10s infinite;
  @keyframes cambioColor {
    0% {
      background-color: #FFFFFF; /* Blanco */
      border-color: #000000; /* Negro */
    }
    50% {
      background-color: #4CAF50; /* Verde */
      border-color: #000000; /* Negro */
    }
    100% {
      background-color: #FFFFFF; /* Blanco */
      border-color: #000000; /* Negro */
    }
  }">
  Calificar el juego
</button>

    <div class='sudoku'>
        <div class="board-and-messages">
            <p id="unsolvable" data-message><span><?xml version="1.0" encoding="utf-8"?>
                <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" width="24" height="24" enable-background="new 0 0 1000 1000" xml:space="preserve" title='incorrect icon'>

                <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
                <g><path d="M500,990C229.4,990,10,770.6,10,500S229.4,10,500,10s490,219.4,490,490S770.6,990,500,990z M500,84.7C270.7,84.7,84.7,270.7,84.7,500S270.7,915.3,500,915.3S915.3,729.3,915.3,500S729.3,84.7,500,84.7z M764.3,764.3c-26.5,26.5-69.6,26.5-96.1,0L500,596.1L331.8,764.3c-26.5,26.5-69.6,26.5-96.1,0c-26.5-26.5-26.5-69.6,0-96.1L403.9,500L235.7,331.8c-26.5-26.5-26.5-69.6,0-96.1c26.5-26.5,69.6-26.5,96.1,0L500,403.9l168.2-168.2c26.5-26.5,69.6-26.5,96.1,0c26.5,26.5,26.5,69.6,0,96.1L596.1,500l168.2,168.2C790.9,694.8,790.9,737.8,764.3,764.3z"/></g>
                </svg>
            </span>

            El sudoku no se puede resolver </p>
            <p id="invalid-board" data-message>
                <span>
                    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                <svg title="warning-icon" version="1.1" id="WARNING" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     width="24" height="24" viewBox="0 0 1800 1800" enable-background="new 0 0 1800 1800" xml:space="preserve">
                <g>
                    <path fill="#333333" d="M770.8,796.605v265.968c0,71.216,57.939,129.154,129.154,129.154c71.209,0,129.148-57.938,129.157-129.154
                        l-0.009-265.964c0-71.215-57.93-129.154-129.148-129.154C828.739,667.456,770.8,725.39,770.8,796.605z M966.08,796.609
                        l0.009,265.96c-0.009,36.469-29.672,66.138-66.135,66.138c-36.464,0-66.133-29.669-66.133-66.134V796.605
                        c0-36.465,29.668-66.129,66.133-66.129C936.417,730.476,966.08,760.145,966.08,796.609z"/>
                    <path fill="#333333" d="M899.954,1231.867c-71.566,0-129.787,58.221-129.787,129.787c0,71.572,58.221,129.796,129.787,129.796
                        c71.569,0,129.791-58.224,129.791-129.796C1029.744,1290.088,971.522,1231.867,899.954,1231.867z M899.954,1428.43
                        c-36.816,0-66.766-29.954-66.766-66.775c0-36.816,29.95-66.767,66.766-66.767c36.814,0,66.768,29.95,66.768,66.767
                        C966.722,1398.476,936.768,1428.43,899.954,1428.43z"/>
                    <path fill="#333333" d="M1790.452,1630.839L927.246,135.725c-5.635-9.75-16.037-15.755-27.292-15.755
                        c-11.258,0-21.659,6.004-27.29,15.755L8.344,1632.76c-5.627,9.751-5.627,21.761,0,31.511c5.631,9.75,16.032,15.755,27.29,15.755
                        h1728.644c0.037,0.004,0.063,0.004,0.089,0c17.4,0,31.511-14.106,31.511-31.51
                        C1795.877,1641.964,1793.882,1635.881,1790.452,1630.839z M90.21,1617.004L899.954,214.5l809.745,1402.503H90.21z"/>
                </g>
                <g>
                </g>
                <g>
                </g>
                <g>
                </g>
                <g>
                </g>
                <g>
                </g>
                <g>
                </g>
                </svg>
                </span> 
                El tablero de sudoku no es válido </p>
            <p id="solved" data-message>Resuelto 
                <span><svg title="check-mark" xmlns="http://www.w3.org/2000/svg"width="24" height="24" viewBox="0 0 24 24"><path class="cls-2" d="M9.71,11.29a1,1,0,0,0-1.42,1.42l3,3A1,1,0,0,0,12,16h0a1,1,0,0,0,.72-.34l7-8a1,1,0,0,0-1.5-1.32L12,13.54Z"/><path class="cls-2" d="M21,11h0a1,1,0,0,0-1,1,8,8,0,0,1-8,8h0A8,8,0,0,1,6.33,6.36,7.93,7.93,0,0,1,12,4a8.79,8.79,0,0,1,1.9.22,1,1,0,1,0,.47-1.94A10.54,10.54,0,0,0,12,2,10,10,0,0,0,5,19.09,9.93,9.93,0,0,0,12,22h0A10,10,0,0,0,22,12,1,1,0,0,0,21,11Z"/></svg></span><span id="timeTaken"></span>
            </p>
            <p id="solving" data-message>
                <span>
                <svg title="gear-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/></svg>
            </span>
                Resolviendo...</p>

            <canvas id="canvas-sudoku"></canvas>
        </div>

        <div class="tools">

            <button id="empty-board" data-operation><svg title="empty-board" viewBox="0 0 16 16" class="bi bi-grid-3x3"
                    fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd"
                        d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5V5h4V1H1.5zM5 6H1v4h4V6zm1 4V6h4v4H6zm-1 1H1v3.5a.5.5 0 0 0 .5.5H5v-4zm1 0h4v4H6v-4zm5 0v4h3.5a.5.5 0 0 0 .5-.5V11h-4zm0-1h4V6h-4v4zm0-5h4V1.5a.5.5 0 0 0-.5-.5H11v4zm-1 0H6V1h4v4z" />
                </svg>
            </button>
            <label for="empty-board">Tablero vacío </label>

            <button id='create-board' data-operation>
                <svg version="1.1" id="Capa_1" title="create-board" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 445.049 445.049"
                    style="enable-background:new 0 0 445.049 445.049;" xml:space="preserve">
                    <path id="XMLID_176_" d="M56.507,73.548c-3.393-3.632-3.2-9.327,0.433-12.72l26.938-25.166c2.619-2.447,6.44-3.106,9.729-1.679
                   c3.288,1.428,5.415,4.67,5.415,8.255v70.863c0,4.971-4.029,9-9,9s-9-4.029-9-9V62.963L69.228,73.98
                   C65.595,77.374,59.9,77.181,56.507,73.548z M437.533,9v170.012c0,4.971-4.029,9-9,9s-9-4.029-9-9v-23.673H300.193v119.338h25.329
                   c4.971,0,9,4.029,9,9s-4.029,9-9,9h-25.329v119.338h25.329c4.971,0,9,4.029,9,9s-4.029,9-9,9h-34.138
                   c-0.063,0.001-0.127,0.002-0.191,0.002c-0.063,0-0.127-0.001-0.191-0.002H154.048c-0.125,0.003-0.254,0.003-0.382,0H16.546
                   c-4.97,0-9-4.029-9-8.999L7.536,284.28c-0.013-0.2-0.02-0.4-0.02-0.604c0-0.202,0.007-0.402,0.02-0.602l-0.01-136.31
                   c-0.006-0.142-0.01-0.283-0.01-0.427c0-0.143,0.003-0.284,0.01-0.426L7.516,9.001c0-2.388,0.948-4.677,2.636-6.364
                   C11.84,0.948,14.129,0,16.516,0h412.017C433.503,0,437.533,4.029,437.533,9z M144.857,292.677H25.537l0.009,119.338h119.312V292.677
                   z M144.857,155.339H25.527l0.008,119.338h119.322V155.339z M144.857,18H25.517l0.009,119.339h119.332V18z M282.193,292.677H162.857
                   v119.338h119.336V292.677z M282.193,155.339H162.857v119.338h119.336V155.339z M282.193,18H162.857v119.339h119.336V18z M419.533,18
                   H300.193v119.339h119.339V18z M435.378,231.685c1.39,1.629,2.154,3.701,2.154,5.843v198.521c0,4.971-4.029,9-9,9H371.8
                   c-4.971,0-9-4.029-9-9V237.527c0-2.142,0.764-4.214,2.154-5.843l28.366-33.234c1.71-2.004,4.212-3.157,6.846-3.157
                   s5.136,1.153,6.846,3.157L435.378,231.685z M419.533,408.026H380.8v19.022h38.733V408.026z M419.533,261.238H380.8v128.788h38.733
                   V261.238z M419.533,240.846l-19.367-22.689L380.8,240.846v2.393h38.733V240.846z M238.798,238.695H189.91c-4.971,0-9,4.029-9,9
                   s4.029,9,9,9h48.888c13.974,0,25.342-11.369,25.342-25.344c0-6.223-2.254-11.928-5.988-16.344
                   c3.734-4.416,5.988-10.121,5.988-16.344c0-13.975-11.369-25.344-25.342-25.344H189.91c-4.971,0-9,4.029-9,9s4.029,9,9,9h48.888
                   c4.048,0,7.342,3.295,7.342,7.345c0,4.049-3.294,7.343-7.342,7.343h-28.77c-4.971,0-9,4.029-9,9s4.029,9,9,9h28.77
                   c4.048,0,7.342,3.295,7.342,7.345C246.14,235.401,242.846,238.695,238.798,238.695z" />
                </svg>
            </button>
            <label for="create-board">Crear tablero </label>

            <button id='reset-board' data-operation><img src="https://github.com/gerrardNwoke/codePen-imgs/blob/main/imgs/reset-icon.png?raw=true"
                    alt="reset-board"></button>
            <label for="reset-board">Reiniciar tablero </label>

            <button id='notes' data-operation><svg title="notes-icon" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512"
                    style="enable-background:new 0 0 512 512;" xml:space="preserve">

                    <path d="M403.914,0L54.044,349.871L0,512l162.128-54.044L512,108.086L403.914,0z M295.829,151.319l21.617,21.617L110.638,379.745
      l-21.617-21.617L295.829,151.319z M71.532,455.932l-15.463-15.463l18.015-54.043l51.491,51.491L71.532,455.932z M153.871,422.979
      l-21.617-21.617l206.809-206.809l21.617,21.617L153.871,422.979z M382.297,194.555l-64.852-64.852l21.617-21.617l64.852,64.852
      L382.297,194.555z M360.679,86.468l43.234-43.235l64.853,64.853l-43.235,43.234L360.679,86.468z" />

                </svg>
                <span id='notes-activity'>off</span>
            </button>

            <label for="notes">Notas</label>

            <button id='quick-solve' data-operation>
                <img src="https://github.com/gerrardNwoke/codePen-imgs/blob/main/imgs/solve-icon.png?raw=true" alt="solved-sudoku">

            </button>
            <label for="quick-solve">Respuesta rápida</label>
        </div>

        <div class='num-inputs'>
            <button data-number id="1">1</button>
            <button data-number id="2">2</button>
            <button data-number id="3">3</button>
            <button data-number id="4">4</button>
            <button data-number id="5">5</button>
            <button data-number id="6">6</button>
            <button data-number id="7">7</button>
            <button data-number id="8">8</button>
            <button data-number id="9">9</button>
            <button data-number id="0">
                <?xml version="1.0" encoding="UTF-8"?>
                <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                <svg
                title="erase-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"
                    id="mdi-eraser" width="24" height="24" viewBox="0 0 24 24">
                    <path
                        d="M16.24,3.56L21.19,8.5C21.97,9.29 21.97,10.55 21.19,11.34L12,20.53C10.44,22.09 7.91,22.09 6.34,20.53L2.81,17C2.03,16.21 2.03,14.95 2.81,14.16L13.41,3.56C14.2,2.78 15.46,2.78 16.24,3.56M4.22,15.58L7.76,19.11C8.54,19.9 9.8,19.9 10.59,19.11L14.12,15.58L9.17,10.63L4.22,15.58Z" />
                </svg>
            </button>
        </div>


        <div class='controls'>
            <div class="solving-controls">
                <label for="visualize-solve">Visualizar respuesta</label>
                <button id='visualize-solve' data-operation>
                    <img src="https://github.com/gerrardNwoke/codePen-imgs/blob/main/imgs/solve-icon.png?raw=true" alt="solved-sudoku">
                    <span id='solve-state'>Empezar </span>
                </button>
                <div class="speed-control">
                    <label for="speed">Velocidad : <span id="speed-value">1 </span>  milisegundos</label>
                    <p class='min-max'> <span class='min'>1</span> <input type="range" min='1' max='1000'
                            id="speed"><span class='max'>1000</span></p>
                </div>
            </div>

            <div class="generate-controls ">
                <label for="generate">Generar tablero </label>
                <button id='generate' data-operation><img src="https://github.com/gerrardNwoke/codePen-imgs/blob/main/imgs/generate-icon.png?raw=true" alt="generated-sudoku"></button>
                <div class="empty-cell">
                    <label for="empty-cell">Celdas vacías : <span id="empty-cell-count">1</span></label>
                    <p class='min-max'> <span class='min'>1</span> <input type="range" min='1' max='80'
                            id="empty-cell"><span class='max'>80</span></p>
            
             

               </div>
            </div>
        </div>

    </div>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<script>
 // Variables para mostrar el creador y la versión del juego
const creador = '<p><strong style="color: black;">Creador:</strong> 👨‍💻 Andrés Álvarez</p>';
const version = '<p><strong style="color: black;">Versión:</strong> 🔢 0.2.0</p>';

// Función para preguntar el nombre al usuario
function preguntarNombre() {
    Swal.fire({
        title: '¡Hola! ¿Cómo estás? 😊',
        text: '¡Qué alegría tenerte aquí! Antes de comenzar, ¿te gustaría que te expliquemos cómo jugar?',
        icon: 'info',
        confirmButtonText: '¡Por supuesto!',
        showCancelButton: false,
        showLoaderOnConfirm: true,
        allowOutsideClick: false,
        preConfirm: () => {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, 500);
            });
        }
    }).then(() => {
        Swal.fire({
            title: '¡Hola! ¿Cuál es tu nombre? 🙌',
            input: 'text',
            inputPlaceholder: 'Por favor, ingresa tu nombre',
            confirmButtonText: 'Continuar',
            showCancelButton: false,
            showLoaderOnConfirm: true,
            allowOutsideClick: false,
            preConfirm: (nombre) => {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        if (nombre === '') {
                            Swal.showValidationMessage('¡Ups! Parece que olvidaste ingresar tu nombre. Por favor, escríbelo.');
                        }
                        resolve(nombre);
                    }, 500);
                });
            }
        }).then((result) => {
            if (result.isConfirmed) {
                const nombre = result.value;
                mostrarInstrucciones(nombre);
            }
        });
    });
}

// Función para mostrar las instrucciones del juego
function mostrarInstrucciones(nombre) {
    Swal.fire({
        title: `¡Hola, ${nombre}! Bienvenido al emocionante mundo del Sudoku. 🎉`,
        html: `
            <div class="container">
                <div class="row">
                    <div class="col">${creador}</div>
                    <div class="col" style="border-left: 2px solid #333; padding-left: 10px;">${version}</div>
                </div>
                <hr style="border-top: 2px solid #333; margin-bottom: 10px;">
                <p class="lead text-left" style="font-size: 18px; line-height: 1.5; margin-bottom: 10px;">¡Prepárate para una aventura de números y diversión! 🎲</p>
                <p class="lead text-left" style="font-size: 18px; line-height: 1.5; margin-bottom: 10px;">El objetivo es simple: ¡llenar el tablero de 9x9 con números del 1 al 9 sin repetirlos en filas, columnas o cuadrados de 3x3! 🔢</p>
                <ul class="list-unstyled text-left" style="margin-bottom: 20px;">
                    <li style="font-size: 18px; margin-bottom: 5px;">¡Crea un nuevo tablero y sumérgete en la diversión! 🔄</li>
                    <li style="font-size: 18px; margin-bottom: 5px;">¿Te sientes atascado? ¡No te preocupes! Puedes ver la solución paso a paso. 🕵️‍♂️</li>
                </ul>
                <p class="lead text-left">¡Buena suerte y que empiece el desafío! 🍀</p>
            </div>
        `,
        icon: 'info',
        confirmButtonText: '¡Comencemos a jugar! 🎮',
        customClass: {
            title: 'h3 animate__animated animate__fadeIn',
            content: 'text-left animate__animated animate__fadeIn',
            confirmButton: 'btn btn-primary animate__animated animate__fadeIn',
            cancelButton: 'btn btn-secondary animate__animated animate__fadeIn'
        }
    }).then(() => {
        mostrarMensajePersonalizado(nombre);
    });
}

// Función para mostrar el mensaje personalizado
function mostrarMensajePersonalizado(nombre) {
    const contenedorMensaje = document.createElement('div');
    contenedorMensaje.classList.add('animate__animated', 'animate__bounceIn', 'mensaje-personalizado');
    contenedorMensaje.innerHTML = `
        <p class="lead" style="font-size: 20px; color: #FF5733;">¡Hola, Querido(a)  ${nombre}! 🌟</p>
        <p class="lead" style="font-size: 18px;">¡Nos alegra mucho que juegues nuestro juego! 🎉</p>
        <p class="lead" style="font-size: 18px;">¡Tu interacción y jugabilidad nos emocionan mucho! 🚀</p>
        <p class="lead" style="font-size: 18px;">¡Gracias por jugar esta versión 0.2.0! 👏</p>
    `;
    Swal.fire({
        html: contenedorMensaje,
        icon: 'info',
        customClass: {
            title: 'h3 animate__animated animate__fadeIn',
            content: 'text-left animate__animated animate__fadeIn',
            confirmButton: 'btn btn-primary animate__animated animate__fadeIn'
        },
        timer: 10000, // Duración en milisegundos (10 segundos)
        timerProgressBar: true, // Muestra una barra de progreso
        allowOutsideClick: false // Evita que el usuario cierre la alerta haciendo clic fuera de ella
    });
}

// Función para mostrar la alerta de calificación
function mostrarAlertaCalificacion() {
    Swal.fire({
        title: '¡Gracias por jugar!',
        html: '¿Cuál es tu calificación para el juego? 😊🌟',
        icon: 'question',
        showCancelButton: true,
        confirmButtonText: 'Enviar',
        cancelButtonText: 'Cancelar',
        reverseButtons: true,
        input: 'range',
        inputAttributes: {
            min: 0,
            max: 5,
            step: 0.5
        },
        inputValue: 0,
        imageUrl: 'https://raw.githubusercontent.com/AndresAlvarezmonvsyo/Im-genes/main/_f50efb9a-4169-4f98-ac9f-62e7e0a60b29%20(1).jpeg',
        imageWidth: 200,
        imageHeight: 200,
        customClass: {
            title: 'h3 animate__animated animate__fadeIn',
            content: 'text-left animate__animated animate__fadeIn',
            confirmButton: 'btn btn-primary animate__animated animate__fadeIn',
            cancelButton: 'btn btn-secondary animate__animated animate__fadeIn'
        }
    }).then((result) => {
        if (result.value >= 4) {
            Swal.fire({
                title: '¡Gracias por tu calificación! 🌟',
                text: '¡Nos alegra mucho que hayas disfrutado del juego! 😊🎉',
                icon: 'success',
                confirmButtonText: 'Cerrar',
                imageUrl: 'https://raw.githubusercontent.com/AndresAlvarezmonvsyo/Im-genes/main/_e588f8ed-9ce4-4c93-adda-082c0e14b5f6.jpeg',
                imageWidth: 200,
                imageHeight: 200,
                customClass: {
                    title: 'h3 animate__animated animate__fadeIn',
                    content: 'text-left animate__animated animate__fadeIn',
                    confirmButton: 'btn btn-primary animate__animated animate__fadeIn'
                }
            });
        } else {
            Swal.fire({
                title: '¡Gracias por tu calificación! 😊',
                text: '¡Nos encantaría recibir tus sugerencias para mejorar el juego! 🛠️👂',
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: 'Enviar sugerencia',
                cancelButtonText: 'Cancelar',
                reverseButtons: true,
                input: 'textarea',
                inputPlaceholder: 'Escribe aquí tu sugerencia...',
                imageUrl: 'https://raw.githubusercontent.com/AndresAlvarezmonvsyo/Im-genes/main/_e588f8ed-9ce4-4c93-adda-082c0e14b5f6.jpeg',
                imageWidth: 200,
                imageHeight: 200,
                customClass: {
                    title: 'h3 animate__animated animate__fadeIn',
                    content: 'text-left animate__animated animate__fadeIn',
                    confirmButton: 'btn btn-primary animate__animated animate__fadeIn',
                    cancelButton: 'btn btn-secondary animate__animated animate__fadeIn'
                }
            }).then((result) => {
                if (result.value) {
                    Swal.fire({
                        title: '¡Gracias por tu sugerencia! 🙌',
                        text: '¡Esto nos ayuda a mejorar cada día más! 😊🚀',
                        icon: 'success',
                        confirmButtonText: 'Cerrar',
                        imageUrl: 'https://raw.githubusercontent.com/AndresAlvarezmonvsyo/Im-genes/main/_e588f8ed-9ce4-4c93-adda-082c0e14b5f6.jpeg',
                        imageWidth: 200,
                        imageHeight: 200,
                        customClass: {
                            title: 'h3 animate__animated animate__fadeIn',
                            content: 'text-left animate__animated animate__fadeIn',
                            confirmButton: 'btn btn-primary animate__animated animate__fadeIn'
                        }
                    });
                }
            });
        }
    });
}

preguntarNombre();

             
  
        
 





      const shuffle = (array) => {
    let curIndex = array.length;
    let randomIndex;

    while (curIndex != 0) {
        randomIndex = Math.floor(Math.random() * curIndex);
        curIndex--;
        [array[curIndex], array[randomIndex]] = [array[randomIndex], array[curIndex]];
    }
    return array;
}

// Create a List of integers
const range = (start, stop, step) => Array.from({ length: ((stop - start) / step) + 1 }, (_, i) => start + (i * step));

// Check if the initial [row, col] value is equal to zero in return values inputted in it
//will have the colour blue
const isZero = (row, col) => {
    for (let slot of emptyCells) {
        if (slot.every((val, index) => val === [row, col][index])) {
            return true;
        }
    }
}

// Returns a random number between one value to another when called
const randInt = (min, max) => Math.floor(Math.random() * ((max - min) + 1)) + min;

// ======================== Helper functions ends

// Setting the sudoku canvas
const sudokuCanvas = document.getElementById('canvas-sudoku');
const dpr = window.devicePixelRatio || 1; // Helps create sharper text on canvas
const ctx = sudokuCanvas.getContext('2d');
let sudokuCanvasWidth = sudokuCanvas.getBoundingClientRect().width;
ctx.canvas.width = sudokuCanvasWidth * dpr;
ctx.canvas.height = sudokuCanvasWidth * dpr;
ctx.scale(dpr, dpr);

// Buttons
const numberButtons = document.querySelectorAll('[data-number]');
const operationButtons = document.querySelectorAll('[data-operation]');

// Message
const messages = document.querySelectorAll('[data-message]');
const timeTakenHTMLElement = document.getElementById('timeTaken');

const removeMessage = () => {
    // Lower message all messages
    messages.forEach(message => {
        const messagePopup = document.getElementById(message.id);
        messagePopup.style.transform = `translateY(0%)`;
        messagePopup.style.zIndex = `-2`;
    })
}

const displayMessage = (messageIdToBeDisplayed) => {
    removeMessage();
    // Raise up specified message
    const messageDisplayed = document.getElementById(messageIdToBeDisplayed);
    messageDisplayed.style.transform = `translateY(-100%)`;
    messageDisplayed.style.zIndex = `-1`;
}



// slider value
const speed = document.getElementById('speed');
const emptyBox = document.getElementById('empty-cell');
speed.value = 10;
emptyBox.value = randInt(1, 70);

// Slider Label and value
const currentSpeedValue = document.getElementById('speed-value');
currentSpeedValue.innerText = speed.value;

const currentEmptyCellCount = document.getElementById('empty-cell-count');
currentEmptyCellCount.innerText = emptyBox.value;


let boardNums = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0,],
[0, 0, 0, 0, 0, 0, 0, 0, 0,],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0]]

const emptyCells = []; // Stores up the clearable values (highlighted in blue)

const mouse = {
    x: 0,
    y: 0,
}

// current position of board that was clicked
const boardLocation = {
    col: 0,
    row: 0,

    // For the larger square
    largeRow: 0,
    largeCol: 0
}

// current position cell
const cellSize = {
    largeCell: sudokuCanvasWidth / 3,  // For the larger square 
    regularCell: sudokuCanvasWidth / 9,
}

// Operation Buttons
const operationBtn = {
    emptyBoard: document.getElementById('empty-board'),
    createBoard: document.getElementById('create-board'),
    resetBoard: document.getElementById('reset-board'),
}

let solvingActivity = false; // if the solving Animation is active
let noteActive = false; // Display notes 
let canBeSolved = true; // If the set sudoku can be solved
let boardIsValid = true; // if theres any misplaced number(s)
let stopSolving = false; // kills the visualize solving animation


// Event Listeners ==============================================

// Input number on specified cell when a number button is clicked
numberButtons.forEach(button => {
    const btnStyle = document.getElementById(button.id);
    btnStyle.style.transition = 'background-color 0.2s ease-in-out';

    button.addEventListener('click', () => {


        if (!solvingActivity) {
            removeMessage();
            boardNums[boardLocation.row][boardLocation.col] = parseInt(button.id);

            if (button.id === '0') {
                emptyCells.push([boardLocation.row, boardLocation.col]);
            }
            updateButtonStatus();
            updateCanvas();
        }
    })

    button.addEventListener('mouseenter', () => {
        if (!solvingActivity) {
            btnStyle.style.backgroundColor = 'hsl(211, 100%, 80%)';
        }
    })

    button.addEventListener('mouseleave', () => {
        if (!solvingActivity) {
            btnStyle.style.backgroundColor = 'hsl(211, 100%, 95%)';
        }
    })
})

operationButtons.forEach(button => {
    const btnStyle = document.getElementById(button.id);
    btnStyle.style.outline = '2px solid white';
    btnStyle.style.backgroundColor = 'rgb(240,240,240)';
    btnStyle.style.transition = 'outline-color 0.2s ease-in-out';

    const styleBtnHoverIn = () => {
        btnStyle.style.outline = '2px solid hsl(211, 100%, 40%)';
    }

    const styleBtnHoverOut = () => {
        btnStyle.style.outline = '2px solid white';
    }

    // Does a specified operation depending on the one clicked
    button.addEventListener('click', () => {
        if (!solvingActivity) {
            removeMessage();
            switch (button.id) {
                case 'empty-board':
                    if (emptyButtonState()) {
                        return;
                    }
                    noteActive = false;
                    removeAllValues();
                    btnStyle.style.outline = '2px solid white'; // hides outline after click
                    break;

                case 'create-board':
                    if (!resetAndCreateButtonState()) {
                        return;
                    }
                    createSudokuBoard();
                    btnStyle.style.outline = '2px solid white'; // hides outline after click
                    break;

                case 'reset-board':
                    if (!resetAndCreateButtonState()) {
                        return;
                    }
                    resetBoard();
                    btnStyle.style.outline = '2px solid white'; // hides outline after click
                    break;

                case 'quick-solve':
                    resetBoard();
                    validBoard();

                    if (boardIsValid) {
                        let startTime = performance.now();
                        solve(0);
                        let endTime = performance.now();
                        timeTakenHTMLElement.innerText = '';
                        timeTakenHTMLElement.innerText = `Tiempo tomado: ${endTime - startTime} milisegundos`;
                        updateCanvas();
                        updateButtonStatus();
                        if (!canBeSolved) {
                            displayMessage('unsolvable');
                        } else {
                            displayMessage('solved');
                        }
                    } else {
                        displayMessage('invalid-board');
                    }
                    break;

                case 'visualize-solve':
                    resetBoard();
                    validBoard();

                    if (boardIsValid) {
                        btnStyle.style.outline = '2px solid hsl(0, 100%, 40%)';
                        solvingActivity = true;
                        displayMessage('solving');
                        solveAnim(0).then(() => {
                            solvingActivity = false;
                            updateCanvas();
                            updateButtonStatus();
                            btnStyle.style.outline = '2px solid white';
                            if (!canBeSolved && stopSolving == false) {
                                displayMessage('unsolvable');
                            } else if (canBeSolved && stopSolving == false) {
                                displayMessage('solved');
                            }
                            stopSolving = false;
                        })
                    } else {
                        displayMessage('invalid-board');
                    }


                    break;

                case 'generate':
                    GenerateSudoku();
                    break;
            }
            updateCanvas();
            updateButtonStatus();
        } else {
            if (button.id == 'visualize-solve') {
                stopSolving = true;
                btnStyle.style.outline = '2px solid white'; // hides outline while the mouse is over the button 
            }
        }

        if (button.id == 'notes') {
            if (!noteActive) {
                noteActive = true;
            } else {
                noteActive = false;
            }
            updateCanvas();
            updateButtonStatus();
        }
    })

    // ==== Button States ====================================
    button.addEventListener('mouseenter', () => {
        if (!solvingActivity) {

            // Checking if the button states of create and rest board is active 
            switch (button.id) {

                case 'empty-board':
                    if (!emptyButtonState()) {
                        styleBtnHoverIn();
                    }
                    break;

                case 'create-board':
                    if (resetAndCreateButtonState()) {
                        styleBtnHoverIn();
                    }
                    break;

                case 'reset-board':
                    if (resetAndCreateButtonState()) {
                        styleBtnHoverIn();
                    }
                    break;

                case 'quick-solve':
                    styleBtnHoverIn();
                    break;

                case 'generate':
                    styleBtnHoverIn();
                    break;

                case 'visualize-solve':
                    styleBtnHoverIn();
                    break;
            }
        }

        if (solvingActivity && button.id === 'visualize-solve') {
            btnStyle.style.outline = '2px solid hsl(0, 100%, 40%)';
        }

        if (button.id === 'notes') {
            styleBtnHoverIn();
        }
    })

    button.addEventListener('mouseleave', () => {
        styleBtnHoverOut();
    }
    )
})

// checks if the positions in the empty cell array contains a number greater than 0 or not
// (number in blue text) and defines the state of the create and reset board button (active or inactive)
function resetAndCreateButtonState() {
    for (zero of emptyCells) {
        row = zero[0];
        col = zero[1];
        if (boardNums[row][col] != 0) {
            operationBtn.createBoard.style.opacity = '1';
            operationBtn.createBoard.style.cursor = 'pointer';
            operationBtn.resetBoard.style.opacity = '1';
            operationBtn.resetBoard.style.cursor = 'pointer';
            return true;
        }
    }

    operationBtn.createBoard.style.opacity = '0.5';
    operationBtn.createBoard.style.cursor = 'default';
    operationBtn.resetBoard.style.opacity = '0.5';
    operationBtn.resetBoard.style.cursor = 'default';
    return false;
}

function emptyButtonState() {
    const styleEmptyBtn = document.getElementById('empty-board');
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (boardNums[row][col] !== 0) {
                styleEmptyBtn.style.opacity = '1';
                styleEmptyBtn.style.cursor = 'pointer';
                return false;
            }
        }
    }

    styleEmptyBtn.style.opacity = '0.5';
    styleEmptyBtn.style.cursor = 'default';
    return true;
}

// notes button indicator ====================
function notesActivity() {
    const notesCurrentState = document.getElementById('notes-activity');
    if (noteActive) {
        notesCurrentState.innerText = 'Prendido';
        notesCurrentState.style.backgroundColor = '#0D7CD9';
        notesCurrentState.style.color = 'white';
    } else {
        notesCurrentState.innerText = 'Apagado';
        notesCurrentState.style.backgroundColor = 'rgb(240, 240, 240)';
        notesCurrentState.style.color = 'black';
    }
}
// =========================

// Solving state indicator
function solveState() {
    const solveState = document.getElementById('solve-state');
    if (solvingActivity) {
        solveState.innerText = 'Detener';
        solveState.style.backgroundColor = 'hsl(0, 100%, 90%)';
        solveState.style.color = 'hsl(0, 100%, 40%)';
    } else {
        solveState.innerText = 'Comenzar';
        solveState.style.backgroundColor = 'hsl(211, 100%, 90%)';
        solveState.style.color = 'hsl(211, 100%, 40%)';
    }
}
// ===================

function disableBtns() {
    // Styles all the buttons with the exception of the visualize according to the solving activity
    if (solvingActivity) {
        numberButtons.forEach(number => {
            number.style.opacity = '0.5';
            number.style.cursor = 'default';
        })

        operationButtons.forEach(operation => {
            if (operation.id !== 'visualize-solve' && operation.id !== 'notes') {
                operation.style.opacity = '0.5';
                operation.style.cursor = 'default';
            }
        })

    } else {
        numberButtons.forEach(number => {
            number.style.opacity = '1';
            number.style.cursor = 'pointer';
        })

        operationButtons.forEach(operation => {
            if (operation.id === 'generate' || operation.id === 'quick-solve') {
                operation.style.opacity = '1';
                operation.style.cursor = 'pointer';
            }
        })
    }
}

// Activates and deactivates buttons according to the events specified
function updateButtonStatus() {
    resetAndCreateButtonState();
    emptyButtonState();
    notesActivity();
    solveState();
    disableBtns();
}

// ============= keyboard event listener
document.addEventListener('keydown', (e) => {
    const keyPressed = `${e.code}`;
    const valuePressed = keyPressed[keyPressed.length - 1];
    if (!solvingActivity) {
        removeMessage();
        switch (keyPressed) {

            case 'Backspace':
                boardNums[boardLocation.row][boardLocation.col] = 0;
                updateButtonStatus();
                updateCanvas();
                break;

            case 'ArrowDown':
                if (boardLocation.row < 8) {
                    boardLocation.row++;
                    boardLocation.largeRow = parseInt(boardLocation.row / 3);
                    updateButtonStatus();
                    updateCanvas();
                }
                break;

            case 'ArrowUp':
                if (boardLocation.row > 0) {
                    boardLocation.row--;
                    boardLocation.largeRow = parseInt(boardLocation.row / 3);
                    updateButtonStatus();
                    updateCanvas();
                }
                break;

            case 'ArrowLeft':
                if (boardLocation.col > 0) {
                    boardLocation.col--;
                    boardLocation.largeCol = parseInt(boardLocation.col / 3);
                    updateButtonStatus();
                    updateCanvas();
                }
                break;

            case 'ArrowRight':
                if (boardLocation.col < 8) {
                    boardLocation.col++;
                    boardLocation.largeCol = parseInt(boardLocation.col / 3);
                    updateButtonStatus();
                    updateCanvas();
                }
                break;
        }

        if ((valuePressed === '0' || keyPressed === 'Backspace') && !isZero(boardLocation.row, boardLocation.col)) {
            boardNums[boardLocation.row][boardLocation.col] = 0;
            emptyCells.push([boardLocation.row, boardLocation.col]);
            updateButtonStatus();
            updateCanvas();
        }

        if (!isNaN(valuePressed) && keyPressed[0] == 'D') {
            boardNums[boardLocation.row][boardLocation.col] = parseInt(valuePressed);
            updateButtonStatus();
            updateCanvas();
        }
    }
})
// ==============================

// draw board according to the size of the screen
window.addEventListener('resize', () => {
    sudokuCanvasWidth = sudokuCanvas.getBoundingClientRect().width;
    const dpr = window.devicePixelRatio || 1;
    ctx.canvas.width = sudokuCanvasWidth * dpr;
    ctx.canvas.height = sudokuCanvasWidth * dpr;
    cellSize.largeCell = sudokuCanvasWidth / 3;
    cellSize.regularCell = sudokuCanvasWidth / 9;
    ctx.scale(dpr, dpr);
    updateButtonStatus();
    updateCanvas();
})
// ===============================================

// get the coordinates of the mouse when clicked
sudokuCanvas.addEventListener('click', (event) => {
    if (!solvingActivity) {
        mouse.x = event.x;
        mouse.y = event.y;
        removeMessage();
        curPosClicked();
        updateButtonStatus();
        updateCanvas();
    }
})
// ================================================

// Range Sliders
speed.addEventListener('input', () => {
    currentSpeedValue.innerText = speed.value;
})

emptyBox.addEventListener('input', () => {
    currentEmptyCellCount.innerText = emptyBox.value;
})
// ======================

// Event Listeners End ==============================================

// Assigning empty cells to differentiate the blue numbers(values that will be cleared when selecting reset btn) and black numbers
function assignEmptyCells() {
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (boardNums[row][col] === 0) {
                emptyCells.push([row, col])
            }
        }
    }
}
assignEmptyCells()
// ======================================================================

// ==== Current position of the board that was clicked
function curPosClicked() {
    const rect = sudokuCanvas.getBoundingClientRect();
    const posY = mouse.y - rect.top;
    const posX = mouse.x - rect.left;
    boardLocation.col = parseInt(posX / cellSize.regularCell);
    boardLocation.row = parseInt(posY / cellSize.regularCell);
    boardLocation.largeCol = parseInt(posX / cellSize.largeCell);
    boardLocation.largeRow = parseInt(posY / cellSize.largeCell);
}

// Area that cannot be filled with the same number on the current cell
function area() {
    ctx.beginPath();
    ctx.fillStyle = 'hsl(211, 100%, 95%)';
    ctx.fillRect(boardLocation.largeCol * cellSize.largeCell, boardLocation.largeRow * cellSize.largeCell, cellSize.largeCell, cellSize.largeCell);
    ctx.stroke();

    // vertical rect
    ctx.beginPath();
    ctx.fillStyle = 'hsl(211, 100%, 95%)';
    ctx.fillRect(boardLocation.col * cellSize.regularCell, 0, cellSize.regularCell, sudokuCanvasWidth);
    ctx.stroke();

    // Horizontal Rect
    ctx.beginPath();
    ctx.fillStyle = 'hsl(211, 100%, 95%)';
    ctx.fillRect(0, boardLocation.row * cellSize.regularCell, sudokuCanvasWidth, cellSize.regularCell);
    ctx.stroke();
}
// =========================================================================

// ============================== Current Cell Position ===================
function curPosSquare() {
    ctx.beginPath();
    ctx.fillStyle = 'hsl(211, 100%, 85%)';
    ctx.fillRect(boardLocation.col * cellSize.regularCell, boardLocation.row * cellSize.regularCell, cellSize.regularCell, cellSize.regularCell);
    ctx.stroke();
}
// ==========================================================================

// ======================= Update The entire Canvas ==================== 
function updateCanvas() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    area();
    if (!solvingActivity) {
        numPositions();
        curPosSquare();
    }

    sudokuBoard();
    sudokuNumPlacement();
    if (noteActive) {
        possibleNumPlacement();
    }
}
// ======================================================================

// ================== Drawing the sudoku board ==========================
function sudokuBoard() {
    for (let i = 1; i < 9; i++) {

        ctx.beginPath();
        // Drawing thin Horizontal Lines
        ctx.lineWidth = 1;
        ctx.moveTo(0, i * cellSize.regularCell)
        ctx.lineTo(sudokuCanvasWidth + 10, (i * cellSize.regularCell) + 0.5);
        ctx.strokeStyle = 'rgb(196,196,196)';
        ctx.stroke();

        // Drawing thin Vertical Lines
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.moveTo(i * cellSize.regularCell, 0.5);
        ctx.lineTo(i * cellSize.regularCell, sudokuCanvasWidth + 0.5);
        ctx.strokeStyle = 'rgb(196,196,196)';
        ctx.stroke();
    }

    for (let i = 1; i < 3; i++) {
        // Drawing thick Horizontal Lines
        ctx.beginPath();
        ctx.moveTo(0, (3 * i * cellSize.regularCell) + 0.5)
        ctx.lineTo(sudokuCanvasWidth + 10, (3 * i * cellSize.regularCell) + 0.5);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgb(15,15, 15)';
        ctx.stroke();

        // Drawing thick Vertical Lines
        ctx.beginPath();
        ctx.moveTo(3 * i * cellSize.regularCell, 0.5);
        ctx.lineTo(3 * i * cellSize.regularCell, sudokuCanvasWidth + 0.5);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgb(15,15, 15)';
        ctx.stroke();
    }
}
// =====================================================================

// ================ Setting the numbers in their proper cells and positions =========================
function sudokuNumPlacement() {
    let posY = cellSize.regularCell / 1.75;
    let posX = cellSize.regularCell / 2;

    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            let numToString = `${boardNums[col][row]}`;
            if (numToString === '0') {
                numToString = ' ';
            }

            // Blue Text (Values that would be cleared if the reset function or empty board function is used)
            if (isZero(col, row)) {
                ctx.font = `300 ${sudokuCanvasWidth / 15}px Poppins`;
                ctx.textBaseline = 'middle';
                const textWidth = ctx.measureText(numToString).width;
                const centerTextHorizontally = posX + (cellSize.regularCell * (row)) - (textWidth / 2);
                ctx.fillStyle = 'hsl(211, 100%, 40%)';
                ctx.fillText(numToString, centerTextHorizontally, posY + (cellSize.regularCell * col));
                // Black Text (Values that would be cleared if only the em)
            } else {
                ctx.font = `400 ${sudokuCanvasWidth / 15}px Poppins`;
                ctx.textBaseline = 'middle';
                const textWidth = ctx.measureText(numToString).width;
                const centerTextHorizontally = posX + (cellSize.regularCell * (row)) - (textWidth / 2);
                ctx.fillStyle = 'black';
                ctx.fillText(numToString, centerTextHorizontally, posY + (cellSize.regularCell * col));
            }
        }
    }
}
// =================================================================================================

// =================== Notes Btn =================================
// Possible Notes Number
function possibleNums(row, col) {
    let numList = range(1, 9, 1);

    for (let i = 0; i < 9; i++) {
        let numIndex = numList.findIndex(num => num == boardNums[row][i]);
        if (numIndex != -1) {
            numList.splice(numIndex, 1);
        }

        numIndex = numList.findIndex(num => num == boardNums[i][col]);
        if (numIndex != -1) {
            numList.splice(numIndex, 1);
        }
    }

    const sqRow = parseInt(row / 3) * 3;
    const sqCol = parseInt(col / 3) * 3;

    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            const numIndex = numList.findIndex(num => num == boardNums[i + sqRow][j + sqCol]);
            if (numIndex != -1) {
                numList.splice(numIndex, 1);
            }
        }
    }
    return numList;
}
// ====================
// Setting the notes numbers in their proper locations within their specified cells 
function possibleNumPlacement() {
    let posY = (cellSize.regularCell / 1.75) / 3;
    let posX = (cellSize.regularCell / 2) / 3;

    for (zeroIndex of emptyCells) {
        row = zeroIndex[0];
        col = zeroIndex[1];

        if (boardNums[row][col] == 0) {
            const numList = possibleNums(row, col);

            // Displays Possible values that can be entered without any error
            for (num of numList) {
                const notePosX = ((num - 1) % 3) * (cellSize.regularCell / 3);
                const notePosY = parseInt((num - 1) / 3) * (cellSize.regularCell / 3);
                const numToString = `${num}`;
                ctx.font = `400 ${sudokuCanvasWidth / 45}px Poppins`;
                const textWidth = ctx.measureText(numToString).width;
                const positionHorizontally = posX + notePosX + (cellSize.regularCell * (col)) - (textWidth / 2);
                ctx.fillStyle = 'grey';
                ctx.fillText(numToString, positionHorizontally, posY + notePosY + (cellSize.regularCell * row));
            }
        }
    }
}
// ====================
// Notes Btn Ends ==============================================


// ========== Checking for the misplaced numbers on the sudoku board
function misplacedNum(row, col, num) {
    let countNumRow = 0;
    for (let i = 0; i < 9; i++) {
        if (boardNums[row][i] == num) {
            countNumRow++;
            // Counts the initial number once when traversing the row thus, 
            // if it appears twice its invalid
            if (countNumRow > 1) {
                return false;
            }
        }
    }

    let countNumCol = 0;
    for (let i = 0; i < 9; i++) {
        if (boardNums[i][col] == num) {
            countNumCol++;
            if (countNumCol > 1) {
                return false;
            }
        }
    }

    const sqRow = parseInt(row / 3) * 3;
    const sqCol = parseInt(col / 3) * 3;

    let countNumSq = 0;
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            if (boardNums[i + sqRow][j + sqCol] == num) {
                countNumSq++;
                if (countNumSq > 1) {
                    return false;
                }
            }
        }
    }
    return true;
}
// ========================================================================

// Highlighting all the other positions of a number on the currently selected cell in blue
// and highlighting numbers place wrongly in red
function numPositions() {
    curRow = boardLocation.row;
    curCol = boardLocation.col;

    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            // show number in other places
            if (boardNums[row][col] == boardNums[curRow][curCol] && boardNums[curRow][curCol] != 0) {
                ctx.beginPath();
                ctx.fillStyle = 'hsl(211, 100%, 90%)';
                ctx.fillRect(col * cellSize.regularCell, row * cellSize.regularCell, cellSize.regularCell, cellSize.regularCell);
                ctx.stroke();
            }

            // Invalid numPlacement
            if (!misplacedNum(row, col, boardNums[row][col]) && boardNums[row][col] !== 0) {
                ctx.beginPath();
                ctx.fillStyle = '#ffcccc';
                ctx.fillRect(col * cellSize.regularCell, row * cellSize.regularCell, cellSize.regularCell, cellSize.regularCell);
                ctx.stroke();
            }
        }
    }
}
// ===========================================

// Check if all the number placements are valid on the board
function validBoard() {
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            const num = boardNums[row][col];
            if (!misplacedNum(row, col, num) && num !== 0) {
                boardIsValid = false;
                return;
            }
        }
    }
    boardIsValid = true;
    return;
}
//  ==============================================================================

// =================== clear all blue text (temporal values) =====================
function resetBoard() {
    for (input of emptyCells) {
        row = input[0];
        col = input[1]
        boardNums[row][col] = 0;
    }
}
// ================================================================

//========================= Empty Board ============================
function removeAllValues() {
    emptyCells.length = 0;
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            boardNums[row][col] = 0;
            emptyCells.push([row, col]);
        }
    }
}
// ======================================================================

// ============= Generate a random Sudoku =============================
function GenerateSudoku() {
    if (emptyCells > 80) {
        return false;
    }

    removeAllValues();
    solve(0); // Setting up random numbers on an empty board

    // Removing the temporal cells (blue texts)
    let fixedCellsCount = 81 - emptyBox.value;
    let maxIndexCount = 80;
    while (fixedCellsCount != 0) {
        const randomIndex = randInt(0, maxIndexCount);
        emptyCells.splice(randomIndex, 1);
        maxIndexCount--;
        fixedCellsCount--;
    }

    resetBoard();
}
// ====================================================================

// ============= Create Sudoku board =====================
// Converting the blue text to be black so it cannot be affected by the reset function
function createSudokuBoard() {
    emptyCells.length = 0;
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (boardNums[row][col] == 0) {
                emptyCells.push([row, col]);
            }
        }
    }
}
// ================================================================

// ============== Sudoku Solver ==========================

// Helper function for Quick and visual solve
function checkCell(row, col, num) {
    for (let i = 0; i < 9; i++) {
        if (boardNums[row][i] == num) {
            return false;
        }
    }

    for (let i = 0; i < 9; i++) {
        if (boardNums[i][col] == num) {
            return false;
        }
    }

    const sqRow = parseInt(row / 3) * 3;
    const sqCol = parseInt(col / 3) * 3;

    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            if (boardNums[i + sqRow][j + sqCol] == num) {
                return false;
            }
        }
    }
    return true
}

// Quick Solve and Generate Helper function
function solve(iteration) {
    if (iteration == 81) {
        canBeSolved = true;
        return boardNums;
    }

    const col = iteration % 9;
    const row = parseInt(iteration / 9);


    if (boardNums[row][col] != 0) {
        return solve(iteration + 1);
    }

    const randomNum = shuffle(range(1, 9, 1))

    for (num of randomNum) {
        if (checkCell(row, col, num)) {
            boardNums[row][col] = num;
            if (solve(iteration)) {
                return true;
            }
        }
        boardNums[row][col] = 0;
    }
    canBeSolved = false;
    return false;
}


// Visualize Solve
// Current Visual Point: Used Primarily on the solving animation function solveAnim
// It displays both the current position of the algorithm and the backtrack
function visualizeAnim(col, row, color) {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect((row * cellSize.regularCell), (col * cellSize.regularCell), cellSize.regularCell, cellSize.regularCell);
    ctx.stroke();
    sudokuBoard();
    sudokuNumPlacement();
    if (noteActive) {
        possibleNumPlacement();
    }
}

// Async Helper Function
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function solveAnim(iteration) {
    if (iteration == 81) {
        solvingActivity = false;
        canBeSolved = true;
        updateCanvas();
        updateButtonStatus();
        return boardNums;
    }

    if (stopSolving) {
        removeMessage();
        return boardNums;
    }

    const row = parseInt(iteration / 9);
    const col = iteration % 9;

    if (boardNums[row][col] != 0) {
        return solveAnim(iteration + 1);
    }

    const randomNum = shuffle(range(1, 9, 1))

    for (num of randomNum) {
        if (checkCell(row, col, num)) {
            boardNums[row][col] = num;
            visualizeAnim(row, col, '#ccffcc');
            await sleep(speed.value);
            if (await solveAnim(iteration)) {
                return true;
            }
        }
    }

    boardNums[row][col] = 0;
    visualizeAnim(row, col, '#ffcccc');
    await sleep(speed.value);
    canBeSolved = false;
    return false;
}
// ======================================================================

// Initial Startup
updateButtonStatus();
updateCanvas();


  
    </script>
</body>
</html>


 
